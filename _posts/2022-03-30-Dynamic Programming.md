---
layout:     post
title:      Dynamic Programming v_0.1 (Leetcode)
subtitle:   
date:       2022-03-30
author:     Ethan
header-img: img/5.jpg
catalog: true
tags:
    - Leetcode
    - Dynamic Programming
---

- [ ] 基础题目
  - [ ] 
- [ ] 背包问题
- [ ] 打家劫舍
- [ ] 股票问题
- [ ] 子序列问题

# 动态规划

- 动态规划和贪心的区别？
  - 贪心没有状态推导，而是从局部直接选最优的
  - 动态规划中每一个状态一定是由上一个状态推导出来的
- **对于动态规划问题五步曲**
  1. 确定dp数组（dp table）以及下标的含义
  2. 确定递推公式
  3. dp数组如何初始化
  4. 确定遍历顺序
  5. 举例推导dp数组

## 1. 基础题目

#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

难度简单405收藏分享切换为英文接收动态反馈

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

 

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

思路：

- 第一步，确定dp数组的意义：dp[i]代表第i个斐波那契数的值
- 第二步，确定递推公式：dp[i] = dp[i-1]+dp[i-2]
- 第三步，dp数组初始化：dp[0] = 0, dp[1] = 1
- 第四步， 确定遍历顺序：从前往后
- 第五步，举例子来验证

代码：

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

难度简单2221收藏分享切换为英文接收动态反馈

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

思路：

- 第一步，确定dp[i]的含义：i层楼有几种爬法
- 第二步，确定递推公式：dp[i] = dp[i-1] *1+dp[i-2] *1 
  - 到第i层，无非是在i-1层走了一步或者在i-2层走了两步
- 第三步确定初始化：dp[1] = 1, dp[2] = 2
- 第四步确定遍历顺序：从i-1和i-2推i，显然是从前往后
- 第五步：举例子

> 之后第四第五步可以不要了

代码：

![image-20220301220750008](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220301220750008.png)

时间和空间复杂度都是O(n), 有空间O(1)的方法

#### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

难度简单814收藏分享切换为英文接收动态反馈

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

思路：

- dp[i] 是第i层的最低花费
- 因为是一定要走到底，所以不用纠结dp是n还是n-1，只要用和cost的长度和下标一样就行
- 默认每一步都要收费，但如果是最后一步，就不收费
  - 这是很重要的，就是决定了dp的递推公式是加`c[i]`, 而最后return的是dp[i-1]和dp[i-2]中小的那个

- 递推关系是什么？第i层的最低花费是min（第i层的花费加上前i-1的最低花费，第i层的花费加上前i-2的最低花费）。
  - `dp[i] = min(dp[i-1], dp[i-2]) +c[i]`
- 初始化：`dp[0] = c[0], dp[1] = c[1]`

代码：

![image-20220330225001498](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220330225001498.png)



#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

难度中等1288收藏分享切换为英文接收动态反馈

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

思路：

- 首先是dp[i,j]，到达i，j点有几种路径

- dp[i] [j]=dp[i-1] [j]+dp[i] [j-1]: 只可能是从上面或者下面来的

- ~~dp[0, 0] = 1~~整个dp都初始化为1

- 这里的初始化方法要注意（二阶的初始化）：里面的for是行，这样每一行都是一个长为n的list

  - 

- 注意把每个点的值初始化为一，这样每走一步都能加一次

- 时间和空间复杂度都是O（m*n）

  

代码：

可以一开始都当1，思路清晰的话，应该是边缘是1

![image-20220303113303814](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220303113303814.png)

![image-20220303143817107](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220303143817107.png)

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

难度中等736收藏分享切换为英文接收动态反馈

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

 

**示例 1：**

![img](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/robot1.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

**示例 2：**

![img](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/robot2.jpg)

```
输入：obstacleGrid = [[0,1],[0,0]]
输出：1
```

思路：

- 相比上一道题，区别就是需要在遍历dp时，需要进行判断，只有没有障碍时，才能使用递推式
- 第一步，确定dp: dp[i] [j]代表从(0,0)到i，j的路线数目
- 第二步，确定递推式：加上障碍判断的dp[i] [j]=dp[i-1] [j]+dp[i] [j-1]，如果有障碍就保持原样，等迭代过掉这个点
- 第三步，初始化：不同于之前的全部为1，这里应该注意如果边缘的地方出现障碍，后面的位置都应该为0
  - <img src="https://raw.githubusercontent.com/xiaominglalala/pic/main/img/20210104114513928.png" alt="63.不同路径II" style="zoom:50%;" />
  - 具体上要判断第一个（0，0）位置是不是障碍，是，直接返回0
  - 然后遍历整个dp的两边，赋值1，因为只写地方只有一种到达的方式
  - <img src="https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220303142846167.png" alt="image-20220303142846167" style="zoom:25%;" />
  - 其他的地方就是dp计算就好了

- 注意，这里给的没有长和宽，要自己提取，提取的方式是
  - 行数：![image-20220303121125370](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220303121125370.png)
  - 列数：![image-20220303121136606](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220303121136606.png)

代码：

<img src="https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220303161319272.png" alt="image-20220303161319272" style="zoom: 67%;" />

#### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

难度中等722

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

思路：

- dp[i]: 对于整数i的最大拆分
- 递推式：dp[i] = max{dp[i], dp[i-j] *j, (i-j) *j}
  - 其中j是从1遍历到i-1
  - dp[i-j] *j是对i-j进行计算最大拆分
  -  (i-j) *j是直接相乘
- 初始化：没必要考虑0和1，从dp[2] = 1开始

代码：

![image-20220303173441326](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220303173441326.png)

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

难度中等1579收藏分享切换为英文接收动态反馈

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 

**示例 1：**

![img](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

思路：

- 确定dp[i]的意义： **1到i为节点组成的二叉搜索树的个数为dp[i]**
- 先举个例子：<img src="https://raw.githubusercontent.com/xiaominglalala/pic/main/img/20210107093129889.png" alt="96.不同的二叉搜索树1" style="zoom:50%;" />
  - 比如n = 3，我们考虑dp[3], 就是元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
  - 元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量 = dp[2]*dp[0]
  - 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量 = dp[1]*dp[1]
  - 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量 = dp[0]*dp[2]

- dp[i] = sum(dp[j]*dp[i-j-1]), 其中j从0到i-1
- 初始化：dp[0] = 1, dp[1] = 1

代码：

<img src="https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20220303180310728.png" alt="image-20220303180310728" style="zoom: 67%;" />

## 2. 背包问题

### 2.1 01背包

- 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

- 举一个例子：

  背包最大重量为4。

  物品为：

  |       | 重量 | 价值 |
  | ----- | ---- | ---- |
  | 物品0 | 1    | 15   |
  | 物品1 | 3    | 20   |
  | 物品2 | 4    | 30   |

  问背包能背的物品最大价值是多少？

- dp数组的意义：即**dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**

- 递推式：

  - `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`
  - **放物品i**：`dp[i - 1][j - weight[i]]` 为背包容量为j - weight[i]的时候不放物品i的最大价值；`dp[i - 1][j - weight[i]] + value[i] `就是背包放物品i得到的最大价值
  - **不放物品i**：`dp[i - 1][j]`(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)

- 初始化：

  - 如果背包容量j为0，无论是选取哪些物品，背包价值总和一定为0：<img src="https://raw.githubusercontent.com/xiaominglalala/pic/main/img/2021011010304192.png" alt="动态规划-背包问题2" style="zoom:50%;" />
  - i为0，存放编号0的物品的时候， j < weight[0]的时候，dp[0] [j] 应该是 0；j >= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品<img src="https://raw.githubusercontent.com/xiaominglalala/pic/main/img/20210110103109140.png" alt="动态规划-背包问题7" style="zoom:50%;" />
  - 对于其他部分 统一把dp数组统一初始为0，更方便一些<img src="https://raw.githubusercontent.com/xiaominglalala/pic/main/img/%25E5%258A%25A8%25E6%2580%2581%25E8%25A7%2584%25E5%2588%2592-%25E8%2583%258C%25E5%258C%2585%25E9%2597%25AE%25E9%25A2%259810.jpg" alt="动态规划-背包问题10" style="zoom:50%;" />
  - 有两个遍历的维度：物品与背包重量；**但是先遍历物品更好理解**

如果使用**一维滚动数组**

> 状态压缩

- dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]

- dp[j]有两个选择，一个是取自己dp[j] ，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i。二者取最大

- ```text
  dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
  ```

  dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

  dp[j - weight[i]] + value[i] 表示容量为j的背包，放入物品i了之后的价值

- dp数组初始化的时候，都初始为0

- 遍历顺序与二维时不同，是倒序遍历，**为了保证物品i只被放入一次！**

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

难度中等1162收藏分享切换为英文接收动态反馈

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

#### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

难度中等391收藏分享切换为英文接收动态反馈

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

 

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

**示例 3：**

```
输入：stones = [1,2]
输出：1
```

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

难度中等1085收藏分享切换为英文接收动态反馈

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```

#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

难度中等650收藏分享切换为英文接收动态反馈

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

 

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

### 2.2 完全背包

### 2.3 多重背包

### 2.4 背包总结

## 3. 打家劫舍

## 4. 股票问题

## 5. 子序列问题

### 5.1 子序列不连续

### 5.2 子序列连续

### 5.3 编辑距离

### 5.4 回文