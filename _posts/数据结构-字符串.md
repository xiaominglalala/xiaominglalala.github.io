---
layout:     post
title:      String
subtitle:   
date:       2022-04-06
author:     Ethan
header-img: img/city_6.jpg
catalog: true
tags:
    - Leetcode
    - String
---

## 字符串

#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

难度简单559

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

 

**示例 1：**

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2：**

```
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

#### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

难度简单273

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

 

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

#### [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

难度简单255

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

 

**示例 1：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

#### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)（hash table）

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false


提示:

1 <= s.length, t.length <= 5 * 104
s 和 t 仅包含小写字母

进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

------

- 定义一个hash table来记录s中每个字母出现次数，设定为record[]
  - 初始化方式是![image-20211120154956349](https://raw.githubusercontent.com/xiaominglalala/pic/main/img/image-20211120154956349.png)
- 使用ord(), 输入一个字符作为参数，返回对应的ASCII数值或者Unicode数值。所以比如记录'a'的出现次数，就是用record[ord(s[i]) - ord('a')]。如果是’a'就是，第一位，在record[0]里记录。'b'在record[1]里面记录。
- 对于s，每次在hash table对应位+1；对于t每次在对应位-1。最后如果hash table 每一位都是0，就没问题。

#### [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)（栈）

给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

 

示例 1：

输入：s = "3+2*2"
输出：7
示例 2：

输入：s = " 3/2 "
输出：1
示例 3：

输入：s = " 3+5 / 2 "
输出：5

------

- 核心点是优先乘除，再做加减。用栈存储数字。
- 用sign存储每个数字前的符号，假设第一个数字前是加号
  - 遍历字符串，如果是数字，用ord()来获取其与ord(0)的大小差距。其中注意要处理多个数字，num= num*10+ord[i]-ord[0], num*10代表多位数字
  - 如果是符号，加号，把后面的i压入栈；减号，把后面的i变为-i压入栈；称号和除号是难点。
    - 乘号，把栈顶的前一个pop出来，和i称了之后压入栈
    - 除号，把栈顶的前一个pop出来，和i除了之后把结果压入栈
  - 最后把栈中元素累加，得到解
- 时间复杂度O(n): 遍历一遍字符串s的长度
- 空间复杂度O(n): 取决于栈的空间，O(n)

#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

示例 1：

输入：haystack = "hello", needle = "ll"
输出：2
示例 2：

输入：haystack = "aaaaa", needle = "bba"
输出：-1
示例 3：

输入：haystack = "", needle = ""
输出：0

------

- KMP和朴素匹配的区别在于

- **KMP 利用已匹配部分中相同的「前缀」和「后缀」来加速下一次的匹配。**

- **KMP 的原串指针不会进行回溯（没有朴素匹配中回到下一个「发起点」的过程）**

- 举个例子：

  - ![image.png](https://pic.leetcode-cn.com/1618742678-lTXSgV-image.png)	对于朴素匹配，在遇到a和f不匹配之后，原串的指针会回溯到b。![9364346F937803F03CD1A0AE645EA0F1.jpg](https://pic.leetcode-cn.com/1618845342-ydYJRp-9364346F937803F03CD1A0AE645EA0F1.jpg)

    而KMP在遇到不匹配后，会看已经匹配的部分是否存在相同的前缀和后缀。

    如果存在，则跳转到前缀的后面。就是e，尝试和a匹配

  - ![image.png](https://pic.leetcode-cn.com/1618755191-ddejks-image.png)

    在尝试匹配后，发现匹配不上，当前是abe，也没有相同的前后缀，所以匹配串回到头部。与此同时，原串维持不变，而非回到头部。

 - 如果严格按照上述解法的话，最坏情况下我们需要扫描整个原串，复杂度为 O(n)O(n)。同时在每一次匹配失败时，去检查已匹配部分的相同「前缀」和「后缀」，跳转到相应的位置，如果不匹配则再检查前面部分是否有相同「前缀」和「后缀」，再跳转到相应的位置 ... 这部分的复杂度是 O(m^2) ，因此整体的复杂度是 O(n * m^2)，而我们的朴素解法是 O(m * n) 的。

 - 我们需要优化的是前缀和后缀部分：**匹配串某个位置跳转下一个匹配位置这一过程是与原串无关的，我们将这一过程称为找 `next` 点。**

 - 举个 🌰，对于匹配串 abcabd 的字符 d 而言，由它发起的下一个匹配点跳转必然是字符 c 的位置。因为字符 d 位置的相同「前缀」和「后缀」字符 ab 的下一位置就是字符 c。

 - 显然我们可以预处理出 next 数组，数组中每个位置的值就是该下标应该跳转的目标位置（ next 点）。

   当我们进行了这一步优化之后，复杂度是多少呢？

   预处理 next 数组的复杂度未知，匹配过程最多扫描完整个原串，复杂度为 O(n。

   因此如果我们希望整个 KMP 过程是 O(m + n）的话，那么我们需要在 O(m)= 的复杂度内预处理出 next数组。

 - 下面是构建next数组的方式。我们统一将前缀表减一作为next数组
   ![KMP精讲4.gif](https://pic.leetcode-cn.com/1599638403-eQrdyh-KMP精讲4.gif)

   - 首先初始化两个指针i，j。i指向后缀终止的位置，j指向前缀终止的位置。初始化j为-1。next[i]中存储的是模式串到i位置处位置，最长的相等前后缀长度。
   - i从1开始，j从-1开始。比较s[i]和s[j+1]。
   - 如果二者不等就是前后缀不等，就要回溯。j变为next[j], next[j]记录着包括j在内的字串的相同的前后缀长度
   - 如果二者相等，i和j同时后移，并且把j，也就是前缀的长度赋给next[i]。

   

